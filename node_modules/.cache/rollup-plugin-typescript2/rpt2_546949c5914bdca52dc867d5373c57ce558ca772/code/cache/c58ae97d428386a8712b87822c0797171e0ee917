{"code":"import fs from 'fs';\nimport recast from 'recast';\nimport parser from '@babel/parser';\nimport { getArgvs } from './utils';\nfunction parse(code) {\n    try {\n        return parser.parse(code, {\n            sourceType: 'module',\n            plugins: [\"typescript\", \"decorators-legacy\"],\n        });\n    }\n    catch (error) {\n        console.log(error);\n    }\n}\nfunction parseOptGrammar(optGrammar) {\n    var match = optGrammar.match(/([a-zA-Z]+)|([^a-zA-Z]+)/g) || [];\n    if (match.length > 1) {\n        return [match[0], match[1]];\n    }\n    else\n        return match;\n}\nfunction matchMermaidGrammar(str) {\n    var pattern = /@m:\\s*(\\s*[^@]+)\\s*(?:@return:\\s*([^@]+))?/;\n    var match = str.match(pattern);\n    var sentences = [];\n    if (match) {\n        var _a = match[1].split(':'), key = _a[0], value = _a[1];\n        var _b = parseOptGrammar(key), opt = _b[0], target = _b[1];\n        if (target) {\n            sentences.push(\"BFF\".concat(opt).concat(target, \": \").concat(value));\n        }\n        else\n            sentences.push(\"\".concat(opt, \" \").concat(value !== null && value !== void 0 ? value : ''));\n        if (match[2]) {\n            sentences.push(\"\".concat(target, \"-->BFF: \").concat(match[2]));\n        }\n    }\n    return sentences;\n}\nvar StartGrammar = \"\\n  sequenceDiagram\\n    Client->>BFF: \\u53D1\\u8D77\\u67E5\\u8BE2\\u8BF7\\u6C42\\n\";\nvar generateMermaid = function () {\n    var argvs = getArgvs();\n    var code = fs.readFileSync(argvs[0], { encoding: 'utf8' }).toString();\n    var ast = parse(code);\n    var map = [];\n    recast.visit(ast, {\n        visitClassMethod: function (self) {\n            var node = self.value;\n            if (node.kind === 'method') {\n                var methodBody = node.body;\n                var innerComments = self.value.body.innerComments;\n                var comments_1 = [];\n                recast.visit(methodBody, {\n                    visitBlockStatement: function (path) {\n                        var blockStatements = path.node.body;\n                        blockStatements.forEach(function (statement) {\n                            comments_1.push.apply(comments_1, (statement.leadingComments || []));\n                        });\n                        return false;\n                    },\n                });\n            }\n            // map[node.key.name] = (innerComments?.length > 0 ? innerComments : comments).map((item: any) => matchMermaidGrammar(item.value))\n            return true;\n        },\n    });\n    // console.log(map)\n    // const res = Object.entries(map).reduce((acc, [key, value])=> {\n    //   if(value.length) {\n    //     let str = StartGrammar\n    //     value.forEach(opts=> {\n    //       opts.forEach(opt => {\n    //         str += `     ${opt} \\n`\n    //       })\n    //     })\n    //     acc[key] = `\\`\\`\\`mermaid\n    //       ${str}\\n\\`\\`\\``\n    //   }\n    //   return acc\n    // }, {} as Record<string, string>)\n    // console.log(res)\n    // const data = Object.values(res)\n    // fs.writeFile(cwd + '/MERMAID.md', data , {}, function (err) {\n    // })\n};\nexport { generateMermaid };\n","references":["/Users/chufang/Projects/mermaid-comment/node_modules/recast/main.d.ts","/Users/chufang/Projects/mermaid-comment/node_modules/@babel/parser/typings/babel-parser.d.ts","/Users/chufang/Projects/mermaid-comment/src/utils.ts"]}
