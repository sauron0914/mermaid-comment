{"code":"import fs from 'fs';\nimport recast from 'recast';\nimport parser from '@babel/parser';\nimport { getArgvs } from './utils';\nfunction parse(code) {\n    try {\n        return parser.parse(code, {\n            sourceType: 'module',\n            plugins: [\"typescript\", \"decorators-legacy\"],\n        });\n    }\n    catch (error) {\n        console.log(error);\n    }\n}\nfunction parseOptGrammar(optGrammar) {\n    const match = optGrammar.match(/([a-zA-Z]+)|([^a-zA-Z]+)/g) || [];\n    if (match.length > 1) {\n        return [match[0], match[1]];\n    }\n    else\n        return match;\n}\nfunction matchMermaidGrammar(str) {\n    const pattern = /@m:\\s*(\\s*[^@]+)\\s*(?:@return:\\s*([^@]+))?/;\n    const match = str.match(pattern);\n    const sentences = [];\n    if (match) {\n        const [key, value] = match[1].split(':');\n        const [opt, target] = parseOptGrammar(key);\n        if (target) {\n            sentences.push(`BFF${opt}${target}: ${value}`);\n        }\n        else\n            sentences.push(`${opt} ${value ?? ''}`);\n        if (match[2]) {\n            sentences.push(`${target}-->BFF: ${match[2]}`);\n        }\n    }\n    return sentences;\n}\nconst StartGrammar = `\n  sequenceDiagram\n    Client->>BFF: 发起查询请求\n`;\nconst generateMermaid = () => {\n    const argvs = getArgvs();\n    const code = fs.readFileSync(argvs[0], { encoding: 'utf8' }).toString();\n    const ast = parse(code);\n    const map = [];\n    recast.visit(ast, {\n        visitClassMethod: function (self) {\n            const node = self.value;\n            if (node.kind === 'method') {\n                const methodBody = node.body;\n                node.decorators.forEach(decorator => {\n                    console.log('decorator', decorator);\n                    const { expression } = decorator ?? {};\n                    const { name } = expression?.callee ?? {};\n                    switch (name) {\n                        case 'request':\n                            const arg = expression.arguments;\n                            console.log('arguments', arg);\n                            break;\n                        case 'summary':\n                            break;\n                        default:\n                            break;\n                    }\n                });\n                const innerComments = self.value.body.innerComments;\n                const comments = [];\n                recast.visit(methodBody, {\n                    visitBlockStatement(path) {\n                        const blockStatements = path.node.body;\n                        blockStatements.forEach((statement) => {\n                            comments.push(...(statement.leadingComments || []));\n                        });\n                        return false;\n                    },\n                });\n            }\n            // map[node.key.name] = (innerComments?.length > 0 ? innerComments : comments).map((item: any) => matchMermaidGrammar(item.value))\n            return true;\n        },\n    });\n    // console.log(map)\n    // const res = Object.entries(map).reduce((acc, [key, value])=> {\n    //   if(value.length) {\n    //     let str = StartGrammar\n    //     value.forEach(opts=> {\n    //       opts.forEach(opt => {\n    //         str += `     ${opt} \\n`\n    //       })\n    //     })\n    //     acc[key] = `\\`\\`\\`mermaid\n    //       ${str}\\n\\`\\`\\``\n    //   }\n    //   return acc\n    // }, {} as Record<string, string>)\n    // console.log(res)\n    // const data = Object.values(res)\n    // fs.writeFile(cwd + '/MERMAID.md', data , {}, function (err) {\n    // })\n};\nexport { generateMermaid };\n","references":["/Users/chufang/Projects/mermaid-comment/node_modules/recast/main.d.ts","/Users/chufang/Projects/mermaid-comment/node_modules/@babel/parser/typings/babel-parser.d.ts","/Users/chufang/Projects/mermaid-comment/src/utils.ts"]}
